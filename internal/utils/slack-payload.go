package utils

import (
	"encoding/json"
	"fmt"
	"strings"
)

func buildSlackPayload(headerText, sectionText, detailsText string) (string, error) {
	payload := map[string]interface{}{
		"blocks": []interface{}{
			map[string]interface{}{
				"type": "header",
				"text": map[string]string{
					"type": "plain_text",
					"text": headerText,
				},
			},
			map[string]interface{}{
				"type": "section",
				"text": map[string]string{
					"type": "mrkdwn",
					"text": sectionText,
				},
			},
			map[string]interface{}{
				"type": "divider",
			},
			map[string]interface{}{
				"type": "section",
				"text": map[string]string{
					"type": "mrkdwn",
					"text": detailsText,
				},
			},
			map[string]interface{}{
				"type": "divider",
			},
			map[string]interface{}{
				"type": "context",
				"elements": []interface{}{
					map[string]string{
						"type": "mrkdwn",
						"text": ":infinity: Generated by the *ReleaseWave*.",
					},
					map[string]string{
						"type": "mrkdwn",
						"text": ":rocket: *ReleaseWave* platform is under development.",
					},
				},
			},
		},
	}

	payloadJSON, err := json.MarshalIndent(payload, "", "  ")
	if err != nil {
		return "", err
	}

	return string(payloadJSON), nil
}

func ReleasePrCreatorSlackPayloadBuilder(rcVersion string, prList []map[string]interface{}) (string, error) {
	var prDetails strings.Builder
	var sections []string
	for i, pr := range prList {
		if pr["url"] != "" || pr["conflictMergePr"] != "" {
			if pr["conflictMergePr"] != "" {
				prDetails.WriteString(fmt.Sprintf(
					"â€¢ *`%s`:*  <%s|:warning: Resolve Conflict PR> -> :pray:Then rerun the RC-automation \n",
					pr["repo"], pr["conflictMergePr"],
				))
			} else {
				prDetails.WriteString(fmt.Sprintf(
					"â€¢ *`%s`:* <%s|:white_check_mark: PR-Link> | %s \n",
					pr["repo"], pr["url"], pr["error"],
				))
			}
		} else {
			prDetails.WriteString(fmt.Sprintf(
				"â€¢ *`%s`:* %s  :white_circle:\n",
				pr["repo"], pr["error"],
			))
		}

		// Split into sections every 5 PRs
		if (i+1)%5 == 0 || i == len(prList)-1 {
			sections = append(sections, prDetails.String())
			prDetails.Reset()
		}
	}

	detailsText := "*PRs by Repository:* \n\n"
	for _, section := range sections {
		detailsText += section + "\n\n"
	}

	headerText := fmt.Sprintf("ðŸš€ Release Candidate Branches for %s", rcVersion)
	sectionText := "Below is a compact list of RC branch PR details for review. ðŸ“‹"

	return buildSlackPayload(headerText, sectionText, detailsText)
}

func PreReleaseErrorSlackPayloadBuilder(rcVersion string, activePrs []map[string]interface{}) (string, error) {
	var prDetails strings.Builder
	var sections []string
	for i, pr := range activePrs {
		prDetails.WriteString(fmt.Sprintf(
			"â€¢ *`%s`:  * <%s|:warning: PR-Link> -> *%s* \n",
			pr["repository"], pr["url"], pr["state"],
		))

		// Split into sections every 5 PRs
		if (i+1)%5 == 0 || i == len(activePrs)-1 {
			sections = append(sections, prDetails.String())
			prDetails.Reset()
		}
	}

	detailsText := "*Active PRs by Repository:* \n\n"
	for _, section := range sections {
		detailsText += section + "\n\n"
	}

	headerText := fmt.Sprintf("ðŸš¨ Pre-Release Check Failure - %s", rcVersion)
	sectionText := "There are active PRs that need to be closed or merged before the release. Please review the list below: ðŸ“‹"

	return buildSlackPayload(headerText, sectionText, detailsText)
}

func ProductionWorkflowDispatchSlackPayloadBuilder(rcVersion string, repoList []string, environment string) (string, error) {
	var repoDetails strings.Builder
	var sections []string
	for i, repo := range repoList {
		repoDetails.WriteString(fmt.Sprintf(
			"â€¢ *`%s`* :rocket: Successfully dispatched! :heavy_check_mark:\n",
			repo,
		))

		// Split into sections every 5 repositories
		if (i+1)%5 == 0 || i == len(repoList)-1 {
			sections = append(sections, repoDetails.String())
			repoDetails.Reset()
		}
	}

	detailsText := "*Repositories Dispatched:* \n\n"
	for _, section := range sections {
		detailsText += section + "\n\n"
	}

	headerText := fmt.Sprintf("ðŸš€ Production Pipeline Dispatch - %s to %s :vertical_traffic_light:", rcVersion, environment)
	sectionText := "The production pipeline has been dispatched for the following repositories: ðŸš€"

	return buildSlackPayload(headerText, sectionText, detailsText)
}
