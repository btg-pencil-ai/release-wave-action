package utils

import (
	"encoding/json"
	"fmt"
	"strings"
)

func buildSlackPayload(headerText, sectionText string, detailsTextSectionList []interface{}) (string, error) {
	payload := map[string]interface{}{
		"blocks": []interface{}{
			map[string]interface{}{
				"type": "header",
				"text": map[string]string{
					"type": "plain_text",
					"text": headerText,
				},
			},
			map[string]interface{}{
				"type": "section",
				"text": map[string]string{
					"type": "mrkdwn",
					"text": sectionText,
				},
			},
			map[string]interface{}{
				"type": "divider",
			},
		},
	}

	payload["blocks"] = append(payload["blocks"].([]interface{}), detailsTextSectionList...)
	payload["blocks"] = append(payload["blocks"].([]interface{}), map[string]interface{}{
		"type": "divider",
	}, map[string]interface{}{
		"type": "context",
		"elements": []interface{}{
			map[string]string{
				"type": "mrkdwn",
				"text": ":infinity: Generated by the *ReleaseWave*.",
			},
			map[string]string{
				"type": "mrkdwn",
				"text": ":rocket: *ReleaseWave* platform is under development.",
			},
		},
	})

	payloadJSON, err := json.MarshalIndent(payload, "", "  ")
	if err != nil {
		return "", err
	}

	return string(payloadJSON), nil
}

func buildDetailsTextSectionList(items []string) []interface{} {
	var detailsTextSectionList []interface{}
	for _, section := range items {
		detailsTextSectionList = append(detailsTextSectionList, map[string]interface{}{
			"type": "section",
			"text": map[string]string{
				"type": "mrkdwn",
				"text": section,
			},
		})
	}
	return detailsTextSectionList
}

func buildSections(items []map[string]interface{}, formatFunc func(map[string]interface{}) string) []string {
	var details strings.Builder
	var sections []string
	for i, item := range items {
		details.WriteString(formatFunc(item))

		// Split into sections every 5 items
		if (i+1)%5 == 0 || i == len(items)-1 {
			sections = append(sections, details.String())
			details.Reset()
		}
	}
	return sections
}

func ReleasePrCreatorSlackPayloadBuilder(rcVersion string, prList []map[string]interface{}) (string, error) {
	formatFunc := func(pr map[string]interface{}) string {
		if pr["url"] != "" || pr["conflictMergePr"] != "" {
			if pr["conflictMergePr"] != "" {
				return fmt.Sprintf(
					"â€¢ *`%s`:*  <%s|:warning: Resolve Conflict PR> -> :pray:Then rerun the RC-automation \n",
					pr["repo"], pr["conflictMergePr"],
				)
			}
			return fmt.Sprintf(
				"â€¢ *`%s`:* <%s|:white_check_mark: PR-Link> | %s \n",
				pr["repo"], pr["url"], pr["error"],
			)
		}
		return fmt.Sprintf(
			"â€¢ *`%s`:* %s  :white_circle:\n",
			pr["repo"], pr["error"],
		)
	}

	sections := buildSections(prList, formatFunc)
	detailsTextSectionList := buildDetailsTextSectionList(sections)

	headerText := fmt.Sprintf("ðŸš€ Release Candidate Branches for %s", rcVersion)
	sectionText := "Below is a compact list of RC branch PR details for review. ðŸ“‹"

	return buildSlackPayload(headerText, sectionText, detailsTextSectionList)
}

func PreReleaseErrorSlackPayloadBuilder(rcVersion string, activePrs []map[string]interface{}) (string, error) {
	formatFunc := func(pr map[string]interface{}) string {
		return fmt.Sprintf(
			"â€¢ *`%s`:  * <%s|:warning: PR-Link> -> *%s* \n",
			pr["repository"], pr["url"], pr["state"],
		)
	}

	sections := buildSections(activePrs, formatFunc)
	detailsTextSectionList := buildDetailsTextSectionList(sections)

	headerText := fmt.Sprintf("ðŸš¨ Pre-Release Check Failure - %s", rcVersion)
	sectionText := "There are active PRs that need to be closed or merged before the release. Please review the list below: ðŸ“‹"

	return buildSlackPayload(headerText, sectionText, detailsTextSectionList)
}

func ProductionWorkflowDispatchSlackPayloadBuilder(rcVersion string, repoList []string, environment string) (string, error) {
	formatFunc := func(repo map[string]interface{}) string {
		return fmt.Sprintf(
			"â€¢ *`%s`* :rocket: Successfully dispatched! :heavy_check_mark:\n",
			repo["repo"],
		)
	}

	var repoItems []map[string]interface{}
	for _, repo := range repoList {
		repoItems = append(repoItems, map[string]interface{}{"repo": repo})
	}

	sections := buildSections(repoItems, formatFunc)
	detailsTextSectionList := buildDetailsTextSectionList(sections)

	headerText := fmt.Sprintf("ðŸš€ Production Pipeline Dispatch - %s to %s :vertical_traffic_light:", rcVersion, environment)
	sectionText := "The production pipeline has been dispatched for the following repositories: ðŸš€"

	return buildSlackPayload(headerText, sectionText, detailsTextSectionList)
}
